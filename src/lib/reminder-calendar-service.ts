import connectDB from './db';
import { Reminder } from '@/models/Reminder';
import { CalendarEvent } from '@/models/CalendarEvent';
import { Application } from '@/models/Application';

interface JobData {
  title: string;
  company: string;
  applicationDeadline?: Date;
}

interface Location {
  address?: string;
  type?: string;
  coordinates?: [number, number];
}

interface Attendee {
  name: string;
  email: string;
  role?: string;
}

export class ReminderCalendarService {

  // Auto-generate reminders for new applications
  async createApplicationReminders(applicationId: string, jobData: JobData) {
    try {
      await connectDB();
      
      const application = await Application.findById(applicationId);
      if (!application) return;

      const reminders = [];
      const now = new Date();

      // Follow-up reminder (3 days after application)
      const followUpDate = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000);
      const followUpReminder = new Reminder({
        userId: application.userId,
        applicationId: application._id,
        jobId: application.jobId,
        title: `Follow up on ${jobData.title} application`,
        description: `Follow up on your application for ${jobData.title} at ${jobData.company}`,
        dueDate: followUpDate,
        dueTime: '10:00',
        type: 'follow_up',
        priority: 'medium',
        isAutoGenerated: true,
        autoGenerationRule: 'application_follow_up',
        notifications: [
          { type: 'in_app', timing: 'on_time' },
          { type: 'email', timing: '1_day_before' }
        ]
      });

      await followUpReminder.save();
      reminders.push(followUpReminder._id);

      // Application deadline reminder (if deadline exists)
      if (jobData.applicationDeadline) {
        const deadlineDate = new Date(jobData.applicationDeadline);
        const reminderDate = new Date(deadlineDate.getTime() - 24 * 60 * 60 * 1000); // 1 day before

        if (reminderDate > now) {
          const deadlineReminder = new Reminder({
            userId: application.userId,
            applicationId: application._id,
            jobId: application.jobId,
            title: `Application deadline for ${jobData.title}`,
            description: `Application deadline is tomorrow for ${jobData.title} at ${jobData.company}`,
            dueDate: reminderDate,
            dueTime: '09:00',
            type: 'application_deadline',
            priority: 'high',
            isAutoGenerated: true,
            autoGenerationRule: 'application_deadline',
            notifications: [
              { type: 'in_app', timing: 'on_time' },
              { type: 'email', timing: 'on_time' },
              { type: 'push', timing: 'on_time' }
            ]
          });

          await deadlineReminder.save();
          reminders.push(deadlineReminder._id);
        }
      }

      // Update application with reminder references
      await Application.findByIdAndUpdate(applicationId, {
        $push: { reminders: { $each: reminders } }
      });

      return reminders;
      
    } catch (error) {
      console.error('Error creating application reminders:', error);
      throw error;
    }
  }

  // Create interview event and related reminders
  async createInterviewEvent(data: {
    applicationId: string;
    title: string;
    startDate: Date;
    endDate: Date;
    type: string;
    location?: Location;
    attendees?: Attendee[];
    preparationNotes?: string;
  }) {
    try {
      await connectDB();
      
      const application = await Application.findById(data.applicationId).populate('jobId');
      if (!application) throw new Error('Application not found');

      // Create calendar event
      const event = new CalendarEvent({
        userId: application.userId,
        applicationId: application._id,
        jobId: application.jobId._id,
        title: data.title,
        startDate: data.startDate,
        endDate: data.endDate,
        type: data.type,
        location: data.location || {},
        attendees: data.attendees || [],
        preparationNotes: data.preparationNotes || '',
        status: 'scheduled',
        priority: 'high',
        reminders: [
          { type: 'in_app', timing: 60 }, // 1 hour before
          { type: 'email', timing: 1440 }, // 1 day before
          { type: 'push', timing: 15 } // 15 minutes before
        ]
      });

      await event.save();

      // Create preparation reminder (1 day before interview)
      const prepDate = new Date(data.startDate.getTime() - 24 * 60 * 60 * 1000);
      const prepReminder = new Reminder({
        userId: application.userId,
        applicationId: application._id,
        jobId: application.jobId._id,
        title: `Prepare for ${data.title}`,
        description: `Prepare for your interview tomorrow: ${data.title}`,
        dueDate: prepDate,
        dueTime: '18:00',
        type: 'interview_prep',
        priority: 'high',
        isAutoGenerated: true,
        autoGenerationRule: 'interview_preparation',
        notifications: [
          { type: 'in_app', timing: 'on_time' },
          { type: 'email', timing: 'on_time' }
        ]
      });

      await prepReminder.save();

      // Link event to reminder
      event.reminderId = prepReminder._id;
      await event.save();

      // Update application
      await Application.findByIdAndUpdate(data.applicationId, {
        $push: { 
          calendarEvents: event._id,
          reminders: prepReminder._id
        },
        status: 'interviewing',
        lastStatusUpdate: new Date()
      });

      return { event, reminder: prepReminder };
      
    } catch (error) {
      console.error('Error creating interview event:', error);
      throw error;
    }
  }

  // Create follow-up reminders after interview
  async createPostInterviewReminders(eventId: string, outcome?: string) {
    try {
      await connectDB();
      
      const event = await CalendarEvent.findById(eventId);
      if (!event) return;

      const reminders = [];
      const now = new Date();

      // Thank you note reminder (same day)
      const thankYouDate = new Date(event.endDate.getTime() + 2 * 60 * 60 * 1000); // 2 hours after
      if (thankYouDate > now) {
        const thankYouReminder = new Reminder({
          userId: event.userId,
          applicationId: event.applicationId,
          jobId: event.jobId,
          title: 'Send thank you note',
          description: `Send a thank you note for your interview: ${event.title}`,
          dueDate: thankYouDate,
          dueTime: thankYouDate.toTimeString().slice(0, 5),
          type: 'follow_up',
          priority: 'high',
          isAutoGenerated: true,
          autoGenerationRule: 'post_interview_thank_you',
          notifications: [
            { type: 'in_app', timing: 'on_time' }
          ]
        });

        await thankYouReminder.save();
        reminders.push(thankYouReminder._id);
      }

      // Follow-up reminder (1 week after interview)
      const followUpDate = new Date(event.endDate.getTime() + 7 * 24 * 60 * 60 * 1000);
      const followUpReminder = new Reminder({
        userId: event.userId,
        applicationId: event.applicationId,
        jobId: event.jobId,
        title: 'Follow up on interview',
        description: `Follow up on your interview: ${event.title}`,
        dueDate: followUpDate,
        dueTime: '10:00',
        type: 'follow_up',
        priority: 'medium',
        isAutoGenerated: true,
        autoGenerationRule: 'post_interview_follow_up',
        notifications: [
          { type: 'in_app', timing: 'on_time' },
          { type: 'email', timing: 'on_time' }
        ]
      });

      await followUpReminder.save();
      reminders.push(followUpReminder._id);

      // Update application with new reminders
      if (event.applicationId) {
        await Application.findByIdAndUpdate(event.applicationId, {
          $push: { reminders: { $each: reminders } }
        });
      }

      return reminders;
      
    } catch (error) {
      console.error('Error creating post-interview reminders:', error);
      throw error;
    }
  }

  // Get upcoming reminders and events
  async getUpcomingItems(userId: string, days: number = 7) {
    try {
      await connectDB();
      
      const endDate = new Date();
      endDate.setDate(endDate.getDate() + days);

      // Get upcoming reminders
      const reminders = await Reminder.find({
        userId,
        dueDate: { $gte: new Date(), $lte: endDate },
        status: { $in: ['pending', 'snoozed'] }
      })
        .populate('applicationId', 'status')
        .populate('jobId', 'title company')
        .sort({ dueDate: 1 })
        .limit(10);

      // Get upcoming events
      const events = await CalendarEvent.find({
        userId,
        startDate: { $gte: new Date(), $lte: endDate },
        status: { $in: ['scheduled', 'confirmed'] }
      })
        .populate('applicationId', 'status')
        .populate('jobId', 'title company')
        .sort({ startDate: 1 })
        .limit(10);

      return { reminders, events };
      
    } catch (error) {
      console.error('Error getting upcoming items:', error);
      throw error;
    }
  }

  // Mark reminder as completed and create follow-up if needed
  async completeReminder(reminderId: string, createFollowUp: boolean = false) {
    try {
      await connectDB();
      
      const reminder = await Reminder.findByIdAndUpdate(
        reminderId,
        { 
          status: 'completed',
          completedAt: new Date()
        },
        { new: true }
      );

      if (!reminder) throw new Error('Reminder not found');

      // Create follow-up reminder if requested
      if (createFollowUp && reminder.type === 'follow_up') {
        const followUpDate = new Date();
        followUpDate.setDate(followUpDate.getDate() + 7); // 1 week later

        const followUpReminder = new Reminder({
          userId: reminder.userId,
          applicationId: reminder.applicationId,
          jobId: reminder.jobId,
          title: `Follow up: ${reminder.title}`,
          description: `Follow up on: ${reminder.description}`,
          dueDate: followUpDate,
          dueTime: reminder.dueTime,
          type: 'follow_up',
          priority: reminder.priority,
          isAutoGenerated: true,
          autoGenerationRule: 'follow_up_chain'
        });

        await followUpReminder.save();

        // Update application with new reminder
        if (reminder.applicationId) {
          await Application.findByIdAndUpdate(reminder.applicationId, {
            $push: { reminders: followUpReminder._id }
          });
        }

        return { completed: reminder, followUp: followUpReminder };
      }

      return { completed: reminder };
      
    } catch (error) {
      console.error('Error completing reminder:', error);
      throw error;
    }
  }

  // Sync with external calendar (placeholder for future implementation)
  async syncWithExternalCalendar(eventId: string, provider: string, calendarId: string) {
    try {
      // This would integrate with Google Calendar, Outlook, etc.
      // For now, just update the sync status
      await CalendarEvent.findByIdAndUpdate(eventId, {
        'externalCalendar.provider': provider,
        'externalCalendar.calendarId': calendarId,
        'externalCalendar.synced': true,
        'externalCalendar.lastSyncAt': new Date()
      });

      return { success: true, message: 'Calendar sync updated' };
      
    } catch (error) {
      console.error('Error syncing with external calendar:', error);
      throw error;
    }
  }

  // Clean up completed/cancelled items
  async cleanupOldItems(daysOld: number = 30) {
    try {
      await connectDB();
      
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysOld);

      // Archive old completed reminders
      const archivedReminders = await Reminder.updateMany(
        {
          status: 'completed',
          completedAt: { $lt: cutoffDate }
        },
        {
          $set: { archived: true }
        }
      );

      // Archive old completed events
      const archivedEvents = await CalendarEvent.updateMany(
        {
          status: 'completed',
          endDate: { $lt: cutoffDate }
        },
        {
          $set: { archived: true }
        }
      );

      return {
        archivedReminders: archivedReminders.modifiedCount,
        archivedEvents: archivedEvents.modifiedCount
      };
      
    } catch (error) {
      console.error('Error cleaning up old items:', error);
      throw error;
    }
  }
}

export const reminderCalendarService = new ReminderCalendarService();